<!--notes with crypto auth-->

<!doctype html>
<html lang='en'>
<head>
 <title>notes with crypto auth</title>
 <meta charset='utf-8' />
 <meta name='viewport' content='width=device-width, initial-scale=1' />
</head>
<body>
<script type='import' name='utils'>
export const create=(obj,args=[])=>Reflect.construct(obj,args);
export const $=document.querySelector.bind(document);
export const h=document.createElement.bind(document);
export const p=(a,b)=>a.appendChild(b);
export const wait=tm=>create(Promise,[
 res=>setTimeout(res,tm)
]);
export const pipe=async(v,arr)=>(
 await(arr.reduce(
  async(p,f)=>await(f(await(p)))
  ,Promise.resolve(v)
 ))
);
export const throttle=(func,tm=0,{
 beforeEach=()=>{},
 afterLast=()=>{}
},to)=>arg=>{
 beforeEach(arg);
 clearTimeout(to);
 to=setTimeout(async(arg)=>{
  await(func(arg));
  afterLast(arg);
 },tm,arg);
};
</script>
<script
 type='import'
 name='customImport'
>
let customizers=[
t=>t.replace(
  /import *{([^}]+)} *from *['"]([^'"]+)['"]/g,
  (a,b,c)=>{
   b=b.replace(/ as /g,':');
   return(
    `const{${b}}=await(`
     +`customImport('${c}')`
    +`)`
   );
  }
 ),
 t=>t.replace(
  /import *([^ ]+) *from *['"]([^'"]+)['"]/g,
  (a,b,c)=>(
   `const{default:${b}}=await(`
    +`customImport('${c}')`
   +`)`
  )
 ),
 t=>t.replace(
  /export +const +([^ =]+)/g,
  (a,c)=>`const ${c}=arExport['${c}']`
 ),
 t=>t.replace(
  /export +(function) +([^ (]+)/g,
  (a,b,c)=>(
   `const ${c}=arExport['${c}']=${b}`
  )
 ),
 t=>t.replace(
  /export *{([^}]+)}/g,
  (a,b)=>(
   b.split(',')
   .map(s=>{
    let[v,k=v]=s.split(' as ');
    v=v.trim();
    k=k.trim();
    return(
     `arExport['${k}']=${v};\n`
    );
   }).join('')
  )
 ),
 t=>t.replace(
  /^ *export +(default)([ ([{])/mg,
  (a,b,c)=>`arExport['${b}']=${c}`
 )
];
const customize=t=>{
 t=customizers.reduce((t,c)=>c(t),t);
 t=`export const arExport=(async(
  arExport={},
  customImport=
  globalThis.customImport
 )=>{
  ${t}
  return(arExport);
 })()`;
 return(t);
};

const fromScript=(nm,el,t)=>{
 el=document.querySelector(
  `script[type='import']`
  +`[name='${nm}']`
 );
 if(!el)return(null);
 t=el.innerHTML;
 return(t);
};

let importMap={};
const fromMap=async(id,url,f,t)=>{
 url=importMap[id];
 if(!url)return(null);
 f=await(fetch(url));
 t=await(f.text());
 return(t);
};

const fromFile=async(filename,f,t)=>{
 if(!filename.startsWith('./'))
 {return(null)}
 f=await(fetch(filename));
 t=await(f.text());
 return(t);
};

let resolvers=[
 fromScript,fromMap,fromFile
];

const resolve=async(id)=>(await(
 Promise.all(resolvers
  .map(async(f)=>await(f(id)))
 )
)).find(t=>!!t);

//not working properly when parallel
let cached={};
const memoize=func=>async(id)=>{
 if(!cached[id]){
  cached[id]=await(func(id));
 }
 return(cached[id]);
};

const appendate=f=>{
 f.appendResolvers=arr=>{
  resolvers.push(...arr);
 };
 f.appendCustomizers=arr=>{
  customizers.push(...arr);
 };
 f.assignImportMap=imp=>{
  Object.assign(importMap,imp);
 };
 return(f);
};

const pseudoImportText=async(t,m64,m)=>{
 m64='data:text/javascript;base64,';
 m64+=btoa(t);
 m=await(import(m64));
 return(m);
};

export const customImport=appendate(memoize(
 async(id,url,f,t,m,arrExport)=>{
  t=await(resolve(id));
  t=customize(t);
  m=await(pseudoImportText(t));
  arrExport=await(m.arExport);
  return(arrExport);
 }
));
</script>
<script
 type='import'
 name='test/customImport/stub'
>
 export default[1,2,3];
</script>
<script
 type='import'
 name='test/customImport'
>
import{log}from'log';
import aaa from'test/customImport/stub';
export const testCustomImport=()=>{
 log(10,{test:'custom import export default'});
 log(10,{aaa});
};
</script>
<script
 type='import'
 name='ui/auth'
>
import {h,p} from 'utils';

export const createMultiStateLoginForm=(
 loginText='',
 checkStatus=()=>({
  isExist:false,
  isOnline:false
 }),
 signIn=()=>false,
 signUp=()=>false,
 logout=()=>true,
 form,input,button,
 statesConstants,
 statesAssigns,
 transit,
 updaters,
 pst={},update,
 st,
 setLoginText,
 setCheckStatusHandler,
 setSignInHandler,
 setSignUpHandler,
 setLogoutHandler
)=>{
form=h('form');
input=h('input');
button=h('button');
p(form,input);
p(form,button);

  statesConstants={
   loginPrompt:{
    inputType:'text',
    placeholder:'Enter login',
    inputDisabled:false,
    buttonTitle:'Next',
   },
   signInPassPrompt:{
    inputType:'password',
    placeholder:'Enter password',
    inputDisabled:false,
    buttonTitle:'SignIn'
   },
   signUpPassPrompt:{
    inputType:'password',
    placeholder:'Enter password',
    inputDisabled:false,
    buttonTitle:'SignUp'
   },
   showUser:{
    inputType:'text',
    placeholder:'login',
    buttonTitle:'Logout',
    inputDisabled:true
   }
  };
  statesAssigns={
   loginPrompt:async(
    {text:login}
   )=>{
    const{
     isExist,isOnline
    }=await(checkStatus(login));
    return{
     login,
     text:'',
     stateId:(isExist?'signInPassPrompt'
      :isOnline?'signUpPassPrompt'
      :'loginPrompt'
     )
    };
   },signInPassPrompt:async(
    {login,text:pass},isOk
   )=>{
    isOk=await(signIn(login,pass));
    return{
     pass,
     text:login,
     stateId:(isOk
      ?'showUser'
      :'loginPrompt'
     )
    };
   },signUpPassPrompt:async(
    {login,text:pass},isOk
   )=>{
    isOk=await(signUp(login,pass));
    return{
     pass,
     text:login,
     stateId:(isOk
      ?'showUser'
      :'loginPrompt'
     )
    };
   },showUser:async(st,isOk)=>{
    isOk=await(logout());
    return(isOk?{
     login:'',
     pass:'',
     stateId:'loginPrompt'
    }:{});
   }
  };

transit=async(st)=>{
 //change state
 Object.assign(st,
  await(statesAssigns[st.stateId](st))
 );
 //make state consistent
 Object.assign(st,
  statesConstants[st.stateId]
 );
 return(st);
}

updaters={
  inputType:v=>{input.type=v},
  text:v=>{input.value=v},
  placeholder:v=>{
   input.placeholder=v
  },inputDisabled:v=>{
   input.disabled=v
  },buttonTitle:v=>{
   button.innerHTML=v
  }
 };
update=st=>{
 Object.entries(st)
 .filter(([k,v])=>!!updaters[k])
 .filter(([k,v])=>v!==pst[k])
 .forEach(([k,v])=>updaters[k](v));
 pst={...st};
};
/*
update=st=>{
 with(input){
  type=st.inputType;
  value=st.text;
  placeholder=st.placeholder;
  disabled=st.inputDisabled;
 }
 with(button){
  innerHTML=st.buttonTitle;
 }
}*/

setLoginText=(text,stateId)=>{
 stateId=!!text
 ?'showUser'
 :'loginPrompt';
 st={
  ...statesConstants[stateId],
  text,
  stateId
 };
 update(st);
};

setCheckStatusHandler=
 f=>{checkStatus=f};
setSignInHandler=
 f=>{signIn=f};
setSignUpHandler=
 f=>{signUp=f};
setLogoutHandler=
 f=>{logout=f};

setLoginText(loginText);

input.oninput=e=>{
 st.text=e.target.value;
 update(st);
};
form.onsubmit=async(e)=>{
 e.preventDefault();
 button.disabled=true;
 st=await(transit(st));
 //alert(JSON.stringify(st));
 update(st);
 button.disabled=false;
};

 return{
  form,
  setLoginText,
  setCheckStatusHandler,
  setSignInHandler,
  setSignUpHandler,
  setLogoutHandler
 };
}
</script>
<script type='import' name='log'>
import{$,h,p}from'utils';
export const log=(id,obj,lg,bd,v)=>{
 lg=$('#log_'+id);
 if(!lg){
  lg=h('div');
  lg.setAttribute('id','log_'+id);
  lg.style.borderBottom
  ='1px dashed black';
  bd=$('body');
  if(!bd){
   bd=h('body');
   p(document.documentElement,bd);
  }
  bd.appendChild(lg);
 }
 v=Object.values(obj)[0];
 lg.innerHTML+=(
  (v===null
  ?'[object]'
  :typeof(v)==='object'
  ?`[object ${v.constructor.name}]`
  :`[${typeof(v)}]`)
  +JSON.stringify(obj)
  +'<br>'
 );
};
</script>
<script
 type='import'
 name='test/log'
>
import{create}from'utils';
import{log}from'log';
export const testLog=(a,b,c,d,c1,d1,buf,dv,bytes)=>{
 log(0,{test:'log function'});
 log(0,{a:()=>1});
 log(0,{b:'tuio'});
 log(0,{c:[]});
 log(0,{d:{}});
 log(0,{c1:[111]});
 log(0,{d1:{a:77}});
 buf=create(ArrayBuffer,[2]);
 log(0,{buf});
 dv=create(DataView,[buf]);
 log(0,{dv});
 bytes=create(Uint8Array,[buf]);
 log(0,{bytes});
 log(0,{n:null});
 log(0,{u:undefined});
 log(0,{n:8});
};
</script>
<script
 type='import'
 name='crypto/auth'
>
import{create,pipe}from'utils';

export const rand=n=>(
 crypto.getRandomValues(
   create(Uint8Array,[n])
  )
);

export const join2=(buf1,buf2,bytes1,bytes2,n,bytes)=>{
 bytes1=create(Uint8Array,[buf1]);
 bytes2=create(Uint8Array,[buf2]);
 n=bytes1.length+bytes2.length;
 bytes=create(Uint8Array,[n]);
 bytes.set(bytes1,0);
 bytes.set(bytes2,bytes1.length);
 return(bytes.buffer);
}

export const join=(bufs,n,res)=>{
 n=bufs.reduce(
  (acc,buf)=>acc+buf.byteLength,0
 );
 res=bufs.reduce(
  (acc,buf,j,arr,bt)=>{
   bt=create(Uint8Array,[buf]);
   acc.bts.set(bt,acc.i);
   acc.i+=bt.length;
   return(acc);
  },{
   bts:create(Uint8Array,[n]),
   i:0
  }
 );
 return(res.bts.buffer);
};

export const buf2hex=(buf,bytes,arr,hex)=>{
 bytes=create(Uint8Array,[buf]);
 arr=Array.from(bytes);
 hex=arr.map(
  b=>b.toString(16).padStart(2,'0')
 ).join('');
 return(hex);
};

export const hex2buf=(hex,arr,bytes)=>{
 arr=hex.match(/.{1,2}/g)
 .map(b=>parseInt(b,16));
 bytes=create(Uint8Array,[arr]);
 return(bytes.buffer);
}

export const hash=async(txt,enc,d,hbuf,hhex)=>{
 enc=create(TextEncoder);
 d=enc.encode(txt);
 hbuf=await(crypto.subtle.digest('SHA-256',d));
 hhex=buf2hex(hbuf);
 return(hhex);
};

const baseUrl='https://jsonstorage.net/api/items/';

export const check=async(id,f,t)=>{
 f=await(fetch(baseUrl+id));
 t=await(f.text());
 return(t==='');
};
export const get=async(url,f,j)=>{
 f=await(fetch(url));
 j=await(f.json());
 return(j);
};
export const put=async(url,obj,p,f,j)=>{
 p={
  method:'put',
  headers:{
   'Content-Type':'application/json'
  },
  body:JSON.stringify(obj),
 };
 f=await(fetch(url,p));
 j=await(f.json());
 return(j);
};

export const register=async(id,userObj={test:111},isOk,r)=>{
 isOk=await(check(id));
 if(!isOk)return(false);
 r=await(put(baseUrl+id,userObj));
 isOk=r.uri&&(r.uri ===baseUrl+id)
 return(isOk);
};

export const login=async(id,pas,r,hpas)=>{
 r=await(get(baseUrl+id));
 hpas=await(hash(pas));
 return(r.hpas==hpas);
};

export const encrypt=async(pubKey,txt,enc,d,buf,hex)=>{
 enc=create(TextEncoder);
 d=enc.encode(txt);
 buf=await(crypto.subtle.encrypt({
  name:'RSA-OAEP'
 },pubKey,d));
 hex=buf2hex(buf);
 return(hex);
};

export const decrypt=async(prKey,cTxt,buf,d,dec,txt)=>{
 buf=hex2buf(cTxt);
 d=await(crypto.subtle.decrypt({
  name:'RSA-OAEP'
 },prKey,buf));
 dec=create(TextDecoder);
 txt=dec.decode(d);
 return(txt);
};

export const pass2key=async(pas,enc,d,key)=>{
 enc=create(TextEncoder);
 d=enc.encode(pas);
 key=await(crypto.subtle.importKey(
  'raw',d,{name:'PBKDF2'},false,
  ['deriveBits', 'deriveKey']
 ));
 return(key);
};

export const key2hmacKey=(key,salt)=>(
 crypto.subtle.deriveKey({
  name:'PBKDF2',
  salt,
  iterations:100000,
  hash:'SHA-256'
 },key,{
  name: 'HMAC',
  hash: {name: 'SHA-512'}
 },true,[
  'sign','verify'
 ])
);

export const sign=(key,d)=>(
 crypto.subtle.sign({
  name:'HMAC',
  hash: {name: 'SHA-512'}
 },key,d)
);
export const verify=(key,sg,d)=>(
 crypto.subtle.verify({
  name:'HMAC',
  hash: {name: 'SHA-512'}
 },key,sg,d)
);

export const key2aesGcmKey=(key,salt)=>(
 crypto.subtle.deriveKey({
  name:'PBKDF2',
  salt,
  iterations:100000,
  hash:'SHA-256'
 },key,{
  name:'AES-GCM',
  length:256
 },false,[
  'encrypt',
  'decrypt'
 ])
);
export const encryptAesGcm=(key,iv,d)=>(
 crypto.subtle.encrypt(
  {name:'AES-GCM',iv},key,d
 )
);
export const decryptAesGcm=(key,iv,buf)=>(
 crypto.subtle.decrypt(
  {name:'AES-GCM',iv},key,buf
 )
);

export const cryptoRegister=async(lgn,pas,userObj={test:111},id,isOk,userJson,enc,d,salt1,salt2,iv,key,key1,key2,sg,sbuf,ebuf,buf,h,r)=>{
 id=await(hash(lgn));
 isOk=await(check(id));
 if(!isOk)return(false);
 userJson=JSON.stringify(userObj);
 enc=create(TextEncoder);
 d=enc.encode(userJson);

 salt1=rand(16);
 salt2=rand(16);
 iv=rand(12);

 key=await(pass2key(pas));
 key1=await(
  key2aesGcmKey(key,salt1)
 );
 key2=await(
  key2hmacKey(key,salt2)
 );

 sg=await(sign(key2,d));
 sbuf=join([salt2,sg,d]);
 ebuf=await(
  encryptAesGcm(key1,iv,sbuf)
 );
 buf=join([salt1,iv,ebuf]);
 h=buf2hex(buf);

 r=await(put(baseUrl+id,{h}));
 isOk=r.uri&&(r.uri===baseUrl+id)
 return(isOk);
};

export const cryptoLogin=async(lgn,pas,id,r,key,buf,salt1,key1,iv,ebuf,sbuf,salt2,key2,sg,d,isOk,dec,txt,obj)=>{try{
 id=await(hash(lgn));
 r=await(get(baseUrl+id));
 key=await pass2key(pas);

 buf=hex2buf(r.h);
 salt1=buf.slice(0,16);
 key1=await(
  key2aesGcmKey(key,salt1)
 );
 iv=buf.slice(16,28);
 ebuf=buf.slice(28);
 sbuf=await(
  decryptAesGcm(key1,iv,ebuf)
 );
 salt2=sbuf.slice(0,16);
 key2=await(
  key2hmacKey(key,salt2)
 );
 sg=sbuf.slice(16,80);
 d=sbuf.slice(80);
 isOk=await verify(key2,sg,d);
 if(!isOk)return(null);
 dec=create(TextDecoder);
 txt=dec.decode(d);
 obj=JSON.parse(txt);
 return(obj);
}catch(e){
 alert(e);
 return(null);
}};


export const sign1=
async(key)=>
async(d,salt2,key2,sg,sbuf)=>{
 salt2=rand(16);
 key2=await(
  key2hmacKey(key,salt2)
 );
 sg=await(sign(key2,d));
 sbuf=join([salt2,sg,d]);
 return(sbuf);
};

export const encrypt1=
async(key)=>
async(d,salt1,iv,key1,ebuf,buf)=>{
 salt1=rand(16);
 iv=rand(12);
 key1=await(
  key2aesGcmKey(key,salt1)
 );
 ebuf=await(
  encryptAesGcm(key1,iv,d)
 );
 buf=join([salt1,iv,ebuf]);
 return(buf);
};

export const put1=
url=>async(obj)=>await(put(url,obj));

export const cryptoStore=async(nm,pass,obj,id,url,key,txt,enc,d,r,isOk)=>{
 id=await(hash(nm));
 url=baseUrl+id;
 key=await(pass2key(pass));
 txt=JSON.stringify(obj);
 enc=create(TextEncoder);
 d=enc.encode(txt);
 r=await(pipe(d,[
  await(sign1(key)),
  await(encrypt1(key)),
  buf2hex,
  h=>({h}),
  put1(url)
 ]));
 isOk=r.uri&&(r.uri===url);
 return(isOk);
};
</script>
<script type='import' name='test/crypto/auth'>
import{create}from'utils';
import{log}from'log';
import{
 rand,
 buf2hex,hex2buf,
 pass2key,
 key2hmacKey,
 sign,verify,
 key2aesGcmKey,
 encryptAesGcm,decryptAesGcm,
 hash,register,login,
 cryptoRegister,cryptoLogin,
 join2,join,
 cryptoStore
}from'crypto/auth';

export const testCryptoAuth=()=>{
log(1,{test:'sign verify'});
(async(login,pas,enc,salt,d,key,key2,sg,hsg)=>{
 login='testlogin';
 pas='pass';

 enc=create(TextEncoder);
 salt=rand(16);

 key=await pass2key(pas);
 log(1,{key});
 key2=await(
  key2hmacKey(key,salt)
 );
 log(1,{key2});
 d=enc.encode(login);
 sg=await sign(key2,d);
 hsg=buf2hex(sg);
 log(1,{hsg});

 sg=hex2buf(hsg);
 b=await verify(key2,sg,d);
 log(1,{b});
})();

log(2,{test:'encrypt decrypt'});
(async(login,pas,enc,salt,iv,d,key,key1,buf,h,dec,txt)=>{
 login='testlogin';
 pas='pass';

 enc=create(TextEncoder);
 salt=rand(16);
 iv=rand(12);

 key=await pass2key(pas);
 log(2,{key});
 key1=await(
  key2aesGcmKey(key,salt)
 );
 log(2,{key1});
 d=enc.encode(login);
 buf=await(
  encryptAesGcm(key1,iv,d)
 );
 h=buf2hex(buf);
 log(2,{h});

 buf=hex2buf(h);
 d=await(
  decryptAesGcm(key1,iv,buf)
 );
 dec=create(TextDecoder);
 txt=dec.decode(d);
 log(2,{txt});
})();

log(3,{test:'register login'});
(async(lgn,pas,hlgn,hpas,r)=>{
 lgn='testlogin';
 pas='pass';

 hlgn=await(hash(lgn));
 hpas=await(hash(pas));
 r=await(register(hlgn,{hpas}));
 log(3,{r});
 r=await(login(hlgn,pas));
 log(3,{r});
})();

log(4,{test:'crypto: register login'});
(async(lgn,pas,r)=>{
 lgn='testlogin444';
 pas='pass';

 r=await(cryptoRegister(lgn,pas,{
  qqq:24567
 }));
 log(4,{r});
 r=await(cryptoLogin(lgn,pas));
 log(4,{r});
})();

log(5,{test:'join function'});
(async(a,abuf,bbuf,cbuf, dbuf)=>{
 a=rand(5);
 log(5,{a});
 abuf=a.buffer;
 log(5,{abuf});
 bbuf=rand(7).buffer;
 log(5,{bbuf});
 cbuf=join2(abuf,bbuf);
 log(5,{cbuf});
 c=create(Uint8Array,[cbuf]);
 log(5,{c});
 cbuf=join([abuf,bbuf]);
 log(5,{cbuf});
 log(5,{cbufLen:cbuf.byteLength});
 c=create(Uint8Array,[cbuf]);
 log(5,{c});
 dbuf=join([abuf,bbuf,cbuf]);
 log(5,{dbuf});
 log(5,{dbufLenOk:(
  dbuf.byteLength===0
  +abuf.byteLength
  +bbuf.byteLength
  +cbuf.byteLength
 )});
})();

log(6,{test:'cryptoStore function'});
(async(r)=>{
 r=await(cryptoStore(
  'test@testnotes',
  'password',
  {aaa:1245}
 ));
 log(6,{r});
})();;
};
</script>
<script type='import' name='tests'>
 import{testLog}from'test/log';
 import{testCustomImport}from'test/customImport';
 import{testCryptoAuth}from'test/crypto/auth';
  
 testLog();
 testCryptoAuth();
 testCustomImport();
</script>
<script type='module'>
(async(
 pseudoImport=async(nm,t,m64,m)=>{
  t=document.querySelector(
   `script[type='import']`
   +`[name='${nm}']`
  ).innerHTML;
  m64='data:text/javascript;base64,';
  m64+=btoa(t);
  m=await(import(m64));
  return(m);
 },name,password
)=>{
 const{customImport}=await(
  pseudoImport('customImport')
 );
 customImport.assignImportMap({
 'preact':'https://cdn.jsdelivr.net/npm/preact/dist/preact.module.js',
 'preact/hooks':'https://cdn.jsdelivr.net/npm/preact/hooks/dist/hooks.module.js',
 'htm':'https://unpkg.com/htm?module'
 });
 globalThis.customImport=customImport;
 const{$,h,p,wait,throttle}=await(customImport('utils'));

 const[
  {createMultiStateLoginForm},
  {
   hash,check,
   cryptoRegister,
   cryptoLogin,
   cryptoStore
  }
 ]=await(Promise.all([
  customImport('ui/auth'),
  customImport('crypto/auth')
 ]));

const{
 form,
 setCheckStatusHandler,
 setSignInHandler,
 setSignUpHandler,
 setLogoutHandler
}=createMultiStateLoginForm('');
const[bd,dv,ta,
 cmdpanel,btnEval,
 btnUpdate,btnAppend,
 btnLoad,btnStore
]=[
 $('body'),
 h('div'),
 h('textarea'),
 h('div'),h('button'),
 h('button'),h('button'),
 h('button'),h('button')
];
form.style.float='right';
p(bd,form);

dv.style.clear='both';
p(bd,dv);

ta.style.width='70%';
ta.style.height='300px';
p(bd,ta);

cmdpanel.style.display='flex';
cmdpanel.style.justifyContent='space-between';

btnLoad.innerHTML='load';
p(cmdpanel,btnLoad);
btnEval.innerHTML='eval';
p(cmdpanel,btnEval);
btnUpdate.innerHTML='update';
p(cmdpanel,btnUpdate);
btnAppend.innerHTML='append';
p(cmdpanel,btnAppend);
btnStore.innerHTML='store';
p(cmdpanel,btnStore);

p(bd,cmdpanel);


const dst={
 name:'public@simplenotes',
 title:'',
 content:'',
 autoeval:false,
 timestamp:Date.now()
};
let st=Object.assign({},dst);
if(localStorage.state){
  Object.assign(st,
   JSON.parse(localStorage.state)
  );
}
let pst={};

const updaters={
 title:({title,content})=>{
  ta.value=`${title}\n${content}`;
 },content:({title,content})=>{
  ta.value=`${title}\n${content}`;
 }
};
const update=st=>{
 Object.entries(updaters)
 .filter(([k])=>st[k]!==pst[k])
 .forEach(([k,f])=>f(st))
// ta.value=`${title}\n${content}`;
};

setCheckStatusHandler(async(
 login,nm,isEmpty,isExist,isOnline
)=>{
 nm=login+'@simplenotes';
 isOnline=navigator.onLine;
 //need check in local storage
 if(isOnline){
  isEmpty=await(check(
   await(hash(nm))
  ));
 }else{
  isEmpty=true;
 }
 isExist=!isEmpty;
 return{isExist,isOnline};
});
setSignInHandler(async(
 login,pass,userObj,isOk
)=>{
 name=login+'@simplenotes';
 password=pass;
 userObj=await(cryptoLogin(
  name,password
 ));
 isOk=!!userObj;
 if(isOk){
  alert(JSON.stringify(userObj));
  Object.assign(st,dst,userObj);
  update(st);
  if(st.autoeval)try{
   eval(st.content);
  }catch(e){alert(e)};
 }
 return(isOk);
});
setSignUpHandler(async(
 login,pass,isOk
)=>{
 name=login+'@simplenotes';
 password=pass;
 Object.assign(st,dst,{
  name,
  timestamp:Date.now()
 });
 isOk=await(cryptoRegister(
  name,password,st
 ));
 update(st);
 return(isOk);
});
setLogoutHandler(()=>{
 alert('logout');
 name='';
 password='';
 Object.assign(st,dst);
 update(st);
 return(true);
});

update(st);
if(st.autoeval)try{
 eval(st.content);
}catch(e){alert(e)};

const updateButtons=(
 {isThrottle},isOffline,mustHide
)=>{
 isOffline=!navigator.onLine;
 mustHide=isThrottle||isOffline;
 btnLoad.disabled=mustHide;
 btnStore.disabled=mustHide;
};
ononline=()=>updateButtons(st);
onoffline=()=>updateButtons(st);

ta.oninput=throttle(async(e)=>{
 //alert(e.target.value);

 const[_,title,content]=e.target.value
 .match(/^(.+)\n?([\s\S]*)$/);
 Object.assign(st,{title,content});
 st.autoeval=title.split(' ')
 .includes('autoeval');
 
 localStorage.state=
  JSON.stringify(st);
},5000,{
 beforeEach:()=>{
  st.isThrottle=true;
  updateButtons(st);
 },
 afterLast:()=>{
  st.isThrottle=false;
  updateButtons(st);
 }
});


btnStore.onclick=async(txt,r)=>{
  r=await(cryptoStore(
   name,password,st
  ));
  alert(r);
};
btnEval.onclick=e=>{
 eval(st.content);
};

//await(customImport('tests'));
})();</script>
</body>
</html>
